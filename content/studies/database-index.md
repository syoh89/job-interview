---
title: 데이터베이스 인덱스 정리
createdAt: 2026-01-23
updatedAt: 2026-02-06
keywords: Database,Index,SQL,CS
category: technical
---

# 공부 문서 제목

## 2026-01-23 - 2026-01-23

## 키워드: Database,Index,SQL,CS

### 키워드 관련 공부한 내역

- 인덱스는 테이블의 특정 컬럼을 기준으로 정렬된 탐색 구조를 유지해 조회 속도를 줄이는 자료구조입니다.
- B-Tree 기반 인덱스는 루트/브랜치/리프 페이지로 구성되며, 범위 조회와 정렬에 유리합니다.
- 인덱스는 읽기 성능을 높이지만, 쓰기(INSERT/UPDATE/DELETE) 시 유지 비용이 발생합니다.
- 선택도(selectivity)와 카디널리티(cardinality)가 높을수록 인덱스 효율이 좋아집니다.
- WHERE, ORDER BY, JOIN 조건에 인덱스가 적절히 맞으면 쿼리 플래너가 인덱스를 사용합니다.
- 함수 적용, 암시적 형 변환, 앞부분 와일드카드(LIKE '%x')는 인덱스 사용을 막을 수 있습니다.
- 복합 인덱스는 컬럼 순서가 중요하며, 앞쪽 컬럼이 조건에 포함돼야 효율이 납니다.
- 커버링 인덱스는 필요한 컬럼을 모두 포함해 테이블 접근을 줄이는 방식입니다.
- FE 관점에서 대량 목록, 검색, 정렬, 페이지네이션 API를 설계할 때 인덱스 영향을 고려해야 합니다.
- 인덱스가 많아지면 저장 공간과 쓰기 비용이 증가하므로 트레이드오프를 관리해야 합니다.

### 키워드 관련 이해한 내역 정리

#### 질문 1

인덱스가 조회 성능을 높이는 원리를 B-Tree 관점에서 설명해 주세요.

#### 답변 1 (작성 완료)

B-Tree는 하나의 노드에 여러 키와 자식 포인터를 담아 하나의 블록을 읽는 것으로 많은 키를 탐색할 수 있도록 설계가 되어있어서, 한 번의 디스크 접근으로 전체 노드를 읽어올 수 있어 매우 효율적입니다. 또한 B-Tree는 모든 리프가 같은 깊이에 있어 균형이 유지되므로, 탐색 시간이 O(logN)를 가지게 되면서, 결과적으로 전체 트리의 높이가 작아져 읽어야 할 페이지 수가 줄어들어 조회 성능이 향상됩니다.
게다가, B-Tree는 키가 정렬된 상태로 유지되므로 특정 키 범위의 레코드를 연속적으로 읽을 때 순차 접근이 매우 효율적이게 되어 인덱스 범위 스캔에서 쓰이기 좋습니다. 이러한 특성 덕분에 ORDER BY 절이 포함된 쿼리에서도 인덱스를 활용하여 정렬 비용을 줄일 수 있습니다.
루트는 탐색 시작점으로 분기 방향을 결정하고, 브랜치는 범위를 좁히며, 리프는 실제 레코드(또는 포인터)를 담아 최종 탐색 결과를 제공합니다.

#### 평가 1 (완료)

- 체크리스트
  - 통과: B-Tree의 정렬된 탐색 구조(로그 시간 탐색) 설명
  - 보완: 루트/브랜치/리프 페이지 역할 언급 (리프만 언급됨)
  - 통과: 범위 조회와 ORDER BY에 유리한 이유 설명
- 피드백
  - 전반적으로 명확합니다. 루트/브랜치/리프의 역할을 1~2문장으로 보강하면 더 완성도 높습니다.

#### 질문 2

인덱스를 추가하면 왜 쓰기 성능이 떨어지나요? 어떤 비용이 발생하나요?

#### 답변 2 (작성 완료)

인덱스의 쓰기 작업에는 INSERT / UPDATE / DELETE가 있고, 이 데이터의 추가·수정·삭제 시마다 해당 인덱스 구조도 일관되게 갱신되어야 하기 때문에 추가적인 CPU 연산, 디스크 I/O, 잠금/동시성 비용, 로그 기록 등이 발생하게 됩니다. 이는 전체 쓰기 처리량의 저하를 불러와 쓰기 성능이 저하되게 됩니다.
예를 들어, INSERT 시에는 새로운 레코드가 추가될 때마다 관련 인덱스 노드에 새로운 키를 삽입해야 하며, 이 과정에서 페이지 분할이 발생할 수 있어 추가적인 I/O가 발생할 수 있습니다. UPDATE 시에는 변경된 컬럼이 인덱스에 포함되어 있다면 기존 키를 삭제하고 새로운 키를 삽입하거나 키 이동하는 작업이 필요하며, DELETE 시에는 해당 키를 인덱스에서 제거하는 작업이 필요합니다. 이러한 모든 작업은 추가적인 오버헤드를 발생시키며, 특히 대량의 쓰기 작업이 빈번한 경우 인덱스 유지 비용이 크게 증가할 수 있습니다.
또한 인덱스가 많아질수록 디스크 사용량이 증가하고, 버퍼 캐시 효율이 떨어져 읽기에도 간접적인 비용이 생길 수 있습니다.

#### 평가 2 (완료)

- 체크리스트
  - 통과: INSERT/UPDATE/DELETE 시 인덱스 갱신 비용 설명
  - 통과: 페이지 분할/정렬 유지 비용 언급
  - 보완: 과도한 인덱스가 저장 공간/IO에 미치는 영향 설명
- 피드백
  - 쓰기 경로 비용 설명이 좋습니다. 인덱스 개수가 많아질 때 디스크 사용량과 캐시 효율 저하도 언급하면 더 좋습니다.

#### 질문 3

복합 인덱스에서 컬럼 순서가 왜 중요한지 예시로 설명해 주세요.

#### 답변 3 (작성 완료)

복합 인덱스는 인덱스 내부에서 컬럼들을 정해진 순서로 결합해 키를 만든 자료구조(B-Tree 등)를 유지하므로, 사전식(lexicographic) 순서로 정렬/비교합니다. 따라서 인덱스의 검색/범위/정렬 동작은 항상 “왼쪽(leading) 컬럼부터” 시작하게 됩니다. 예를 들어, (A, B) 순서로 복합 인덱스가 생성된 경우, A 컬럼에 대한 조건이 먼저 평가되고, 그 다음에 B 컬럼이 평가됩니다. 그러므로 WHERE 절에서 A 컬럼이 포함되지 않으면 인덱스가 제대로 활용되지 않을 수 있습니다. WHERE A = x AND B = y → (A,B) 인덱스를 사용해 바로 해당 리프로 접근 가능하게 되는 것입니다.
쿼리의 예시로 보자면, 최근 특정 사용자 주문을 조회하는 경우 `SELECT * FROM orders WHERE user_id = "특정아이디" AND order_date >= '2023-01-01' ORDER BY order_date DESC;` 와 같은 쿼리가 있을 때, (user_id, order_date) 순서로 복합 인덱스를 생성하면 user_id 조건으로 먼저 필터링한 후, order_date 조건과 정렬에 인덱스를 활용할 수 있어 효율적입니다. 반면, (order_date, user_id) 순서로 인덱스를 생성하면 user_id 조건이 뒤에 오기 때문에 인덱스가 제대로 활용되지 않을 수 있습니다.
JOIN 예시로는 orders(user_id, created_at) 인덱스가 있을 때 users와 orders를 user_id로 조인하고 created_at으로 정렬하면 인덱스를 타고 조인 + 정렬까지 효율적으로 처리할 수 있습니다.

#### 평가 3 (완료)

- 체크리스트
  - 통과: 선두 컬럼 매칭 원리 설명
  - 보완: WHERE, ORDER BY, JOIN 조건 조합 예시 제시 (JOIN 예시 없음)
  - 통과: 잘못된 순서가 인덱스 미사용으로 이어짐을 설명
- 피드백
  - 예시가 좋습니다. JOIN 조건이 포함된 케이스를 1줄만 추가하면 면접 답변 완성도가 올라갑니다.

#### 질문 4

EXPLAIN 결과를 보고 인덱스가 사용되었는지 어떻게 판단하나요?

#### 답변 4 (작성 완료)

EXPLAIN 명령어는 쿼리 실행 계획을 보여주며, 여기서 인덱스 사용 여부를 판단할 수 있습니다. EXPLAIN은 보통 “추정(estimated)”을 보여주기 때문에 계산된 비용/행수는 실제와 다를 수 있습니다. 그러므로 인덱스가 사용되었는지를 알아보 주요 포인트는 다음과 같습니다:

1. MySQL의 경우 접근 유형이 어떠한지를 확인해야 하고, PostgreSQL의 경우 어떤 스캔 방식인지를 확인해야 합니다. 전체 스캔(Seq/ALL)인가, 인덱스 기반 Scan(Index/Index Only/Bitmap)인가를 봅니다. 인덱스 스캔이 나타나면 인덱스가 사용된 것입니다.
2. actual rows vs plan rows: EXPLAIN ANALYZE를 사용하면 실제 실행 시의 행 수(actual rows)와 계획된 행 수(plan rows)를 비교할 수 있습니다. 인덱스가 사용되면 실제로 처리되는 행 수가 계획된 행 수보다 훨씬 적을 가능성이 높습니다. 그러므로 예상 rows와 실제 rows 차이가 크면 통계(ANALYZE) 갱신 및 extended statistics 고려할 수 있습니다.
3. 인덱스 사용 시 비용(cost)이 낮아지는 경향이 있습니다. 인덱스가 사용되면 전체 테이블 스캔보다 비용이 낮아지므로, 비용 수치를 통해 인덱스 사용 여부를 유추할 수 있습니다.

#### 평가 4 (완료)

- 체크리스트
  - 통과: Index Scan/Index Only Scan/Bitmap Index Scan 구분
  - 통과: Seq Scan 대비 비용/행 수 비교 언급
  - 통과: 통계/카디널리티가 플래너 선택에 영향 설명
- 피드백
  - 핵심 포인트가 잘 정리됐습니다. PostgreSQL 기준이면 rows/loops 해석을 덧붙이면 더 좋습니다.

#### 질문 5

FE 관점에서 검색/정렬/페이지네이션 API 설계 시 인덱스를 어떻게 고려하나요?

#### 답변 5 (작성 완료)

FE 관점에서의 검색/정렬/페이지네이션이라 함은 사용자가 빠르게 필터(검색) 및 정렬된 항목을 보고, 스크롤 혹은 페이지 전환이 즉각적으로 반응해야 하는 것으로 고려됩니다. 특히 첫 페이지 응답성과 추가 페이지(무한 스크롤, 리다이렉션 등)의 응답 시간과 일관성이 중요시 될 것입니다. 따라서, 이러한 요구사항을 만족시키기 위해서는 다음과 같은 인덱스 활용 전략이 필요합니다:

1. FE가 자주 요청하는 쿼리 패턴을 분석하여 WHERE 절과 ORDER BY 절에 맞는 인덱스를 설계하거나 인덱스만으로 처리하면 랜덤 I/O(테이블 접근)를 최소화할 수 있는 커버링 인덱스를 생성합니다.
2. 페이지네이션 전략으로 OFFSET 기반이 아닌 cursor 기반 페이지네이션을 사용하여, 인덱스를 활용한 효율적인 탐색이 가능하도록 합니다. 또한 cursor 기반은 새로 추가된 항목이 앞에 오더라도 페이징은 이어지는 일관성이 있습니다. 이는 무한 스크롤에도 친화적입니다.

이를 기반으로 API를 설계 시, 기본 파라미터로 필터 조건, 정렬 기준, 페이지 크기, 커서 값을 명확히 정의하고, 쿼리 최적화를 위해 인덱스 활용을 극대화하는 방향으로 설계합니다. 응답 포맷도 필요한 데이터만 포함하여 전송량을 최소화합니다. 에러/경계 사례도 고려하여, 예를 들어 커서가 유효하지 않거나, 페이지 크기가 너무 클 경우 적절한 에러 메시지를 반환하도록 합니다.

이를 통해 FE에서는 기능적인 주요 조회 시나리오(정렬 우선순위, 필터 조합, 빈도, 응답 시간 등)를 고려하고, 페이지 랜딩이나 무한 스크롤 같은 UX 요구사항을 만족시키는 API를 설계할 수 있게 되고, BE에서는 지원 가능한 sort/filter whitelist, cursor 형식, max_limit 등을 정의하여 인덱스 활용을 극대화할 수 있습니다.
정렬 키는 중복이 없는 기준(예: created_at + id)으로 안정성을 확보하고, 인덱스 컬럼 순서와 정렬 기준을 맞춰야 합니다.

#### 평가 5 (완료)

- 체크리스트
  - 통과: WHERE + ORDER BY + LIMIT 조합 최적화 설명
  - 보완: 안정적인 정렬 기준과 인덱스 맞춤 설계 언급 (정렬 키 안정성 명시가 약함)
  - 통과: 커서 기반 페이지네이션 등 인덱스 활용 전략 설명
- 피드백
  - API 설계 관점이 좋습니다. 정렬 키를 "중복 없는 기준 + tie-breaker"로 잡아 인덱스와 정렬 안정성을 맞추는 설명을 추가하면 더 탄탄합니다.

### 키워드 연관된 내용

- 실행 계획(EXPLAIN/EXPLAIN ANALYZE)을 통해 실제 사용 인덱스와 비용을 확인했습니다.
- 인덱스 통계가 부정확하면 플래너가 Seq Scan을 선택할 수 있습니다.
- Index Only Scan은 테이블 접근을 줄이지만, 가시성 맵(VACUUM)이 필요합니다.
- 범위 조건 + 정렬 조합은 인덱스 설계 방향을 결정합니다.

### 더 공부해야 할 관련 내용

- 커버링 인덱스와 복합 인덱스 설계
- 부분 인덱스(Partial Index)와 함수 인덱스(Function Index)
- 인덱스 튜닝 시 통계 갱신과 VACUUM 영향
- 대량 쓰기 트래픽에서 인덱스 전략(최소 인덱스 vs 조회 최적화)
- 클러스터드 인덱스/비클러스터드 인덱스 차이

#### 참조 출처

- PostgreSQL 공식 문서
